% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\begin{center}

{\Large\MakeUppercase{\getFaculty{}}}\\

\vspace{5mm}
{\large\MakeUppercase{\getUniversity{}}}\\

\vspace{10mm}
{\Large \getDoctype{}}

\vspace{10mm}
{\Large\bfseries \getTitle{}}

\vspace{10mm}
{\Large\bfseries \foreignlanguage{ngerman}{\getTitleGer{}}}

\vspace{15mm}
\begin{tabular}{l l}
	Author:          & \getAuthor{} \\
	Supervisor:      & \getSupervisor{} \\
	%Advisor:         & \getAdvisor{} \\
	Registration Date: & \getSubmissionDate{} \\
\end{tabular}

\vspace{20mm}
\end{center}

\section*{Introduction}\label{section:introduction}
Trends in the automotive industry are shaping the future of cars in a way that electronic and computing devices are becoming increasingly important. In fact, the majority of innovations in the automotive sector are related to electronic systems, either in the form of hardware or software. Developments such as vehicle electrification, autonomous driving, driver assistance and better infotainment systems are only some examples of automotive applications where computer processing has a big relevance. It is therefore reasonable to seek for approaches to ensure their usage is efficient and safety requirements are met.

In modern cars, dozens of computers, commonly known as electronic control units (ECUs), execute the various computing tasks present in a car. This number is likely to increase if we consider past trends: as the tasks performed by ECUs often have safety-critical constraints, such as real-time capabilities, they are commonly integrated to serve a specific purpose, avoiding conflicts caused by the parallel execution of other tasks. However, this strategy has shortcomings in the form of inefficient usage of the electronic devices (many tasks are only executed in specific and rare situations), reduced fault tolerance if a system fails, and increased weight and cost of the vehicle due to the high number of ECUs and cables. Hence, it is an important topic in the automotive industry to find solutions for these issues, especially optimizing costs, while ensuring vehicle safety is kept~\parencite{mckinsey1}.

ECU consolidation is an approach for the reduction in the number of electronic devices in the car. The idea is to consolidate the execution of the tasks from many single-purpose ECUs to a few powerful, multi-purpose ECUs. However, the implementation of ECU consolidation raises other challenges: as more tasks need to be executed on the same platform, higher computation and safety requirements must be met. Regarding safety, it is important to consider the added complexity, and cases where a hardware or software failure occur need to be considered, since a single failure could block many tasks and cause major issues. Also, some safety-critical tasks require redundancy to ensure their correct execution. These challenges have motivated previous research at the chair of operating systems of the Technical University of Munich, where research on projects such as KIA4SM and MaLSAMi has explored the concept of dynamic task migration as a process where the execution of any tasks could move at any given time from one ECU to another. This would allow tasks to finish execution in case an ECU is overloaded or stops working, effectively allowing them to finish executing and meet their real-time constraints.

Previous work at the chair has divided the task migration process in two stages: planning and execution. The planning is the stage which generates a task distribution to the devices that will execute them. The execution is then responsible for allowing tasks to migrate from one device to another, while ensuring their progress is not lost and the execution continues and finishes correctly at the target device. So far, the work performed at the chair has explored the approach with a single criticality level, using different priority strategies for scheduling the tasks on an ECU (that is, deciding which task should get the processor and be executed at a given time). While this idea is in itself an important contribution, it is relevant to note that in many safety-critical embedded applications, such as the aerospace and automotive industries, different criticality levels exist, which are often defined in standards such as the ISO 26262, which defines the ASIL (automotive safety integrity level). For example, in a car, the correct functioning of the ABS is highly critical, as a failure could be fatal. In contrast, the functionality of the radio system has a lower criticality, as an eventual failure would not cause any issue other than an unpleasant trip. This idea is also important because in these industries there exist certification agencies that validate a system before it can be distributed.

For this reason, and due to the relevance of the concept of mixed-criticality in many industries, it would be important to expand the research on task migration to explore its integration. In particular, expanding the execution stage to ensure tasks with higher criticality are always able to execute properly and meet their deadline is crucial. But also it is important to find a balance between resource efficiency and reliability of the migration process for different criticality levels. Therefore, the work proposed as part of this PhD program aims to implement a strategy for the migration execution at different levels of criticality. Additionally, the mixed-criticality concept has to be integrated as well into the planning stage. This will be also explored in the scope of this research, although the main focus will be in the execution stage.

Although the work performed as part of this research is based on previous developments at the chair and will likely extend existent tools, it includes the development of a platform that implements mixed-criticality scheduling, as well as a migration system that involves the concept in different areas in the planning and execution stages. This includes the selection of hardware and software, as well as network interfaces. Also, verification of the algorithms used will be performed to ensure safety and timing requirements are met.

\section*{Related Work}\label{section:relatedwork}
At the chair, previous research projects, such as KIA4SM and MaLSAMi, have explored the possibility of migrating tasks running on a device to another in a real-time capable system (for example, ECUs in a vehicle) under certain conditions. As mentioned before, in these works, the migration was divided into two main stages: The first is the migration planning, which determines the hardware that tasks will be migrated to, should the original hardware not be able to fulfill its duty (for example, if there is a failure in that hardware or if the real-time constraints or deadlines would be violated). The second is the execution of the migration, which ensures that corresponding tasks can be migrated from the source device to the target device while keeping their current state.

The migration execution has been explored previously at the chair, for example in projects KIA4SM and HaCRoM. This was explored in the form of a real-time checkpoint-restore mechanism. This involves creating and storing a snapshot of running tasks in a shared memory or copying the memory from a device to another. The work is based on Fiasco.OC and Genode OS. 

MaLSAMi and subsequent theses analyzed migration planning, with researchers performing schedulability analysis based on machine learning (specifically, on neural networks). Machine learning was picked over traditional mathematical approaches such as the ones proposed by Buttazzo, because the recurrent calculations can become too complex for complex tasks and for big task sets, and they often lead to a pessimistic calculation of the system utilization. By predicting the feasibility of a task set using machine learning algorithms, potentially faster but less precise results are obtained, as demonstrated by previous theses by Taieb~\parencite{taieb1}, Utz~\parencite{utz1} and Blieninger~\parencite{blieninger1}. The predictions provided by the machine-learning approach indicate whether a task set is 100\% schedulable or not, but they are not completely safe, since false positive predictions may occur. This approach could be a potentially powerful solution for enabling the execution at run-time of the real-time capable migration planning. 

Additionally, a few different platforms and setups have been explored in these projects. The used operating systems running on the ECUs are Genode OS, as used in MaLSAMi and a few theses, a real-time operating system based on an extension of Genode OS with Fiasco.OC, as used in KIA4SM and HaCRoM, and FreeRTOS, as used by Delgadillo. These developments are considered in the selection of the platform.

Although all these projects have achieved research-relevant results in their segments, the concept of mixed-criticality has not been explored in related chair internal work. It is therefore necessary to look at relevant chair-external work. In particular, those regarding mixed-criticality scheduling strategies and related to task migration.



\section*{Description of the Approach}\label{section:descriptionapproach}

As mentioned before, the main objective of the proposed research is to achieve the integration of mixed criticality into the task migration process. The proper integration would require different strategies for the different criticality modes. For this reason, it is first important to define what is understood under mixed criticality in the scope of this work. While many publications consider only two criticality levels (high and low), the standards commonly describe several of them. In this work, the concept of multiple criticality levels will be used, aiming for an implementation with at least 3 to 4 levels, or following the ASIL standard in ISO 26262. An extension to an arbitrary number of criticality levels is to be explored too.

The first element that is needed in the system developed is the integration of a mixed-criticality scheduler for each of the devices. This should ensure that for any given device, the tasks with a higher criticality will never miss the deadline for a job, while being more flexible for lower criticality levels. In this regard, exploring different mixed-criticality scheduling algorithms and their integration in the development platform is an important step that will allow the migration to occur and be evaluated properly. Several publications have proposed mixed-criticality scheduling algorithms, such as ..., and a few of them can be implemented and compared. Also, to ensure that all ECUs in the system share the notion of time, a timing protocol such as PTP should be implemented to keep the devices synchronized. This way, even when migrating a task, information on the deadlines should be very accurate.

Second, as the migration planning will be adapted from previous work, a few changes are necessary to integrate with the concept of mixed criticality. First, the schedulability analysis that is commonly used for selecting the best task distribution has to be extended to work with criticality levels and the use of a mixed-criticality scheduler. Here, it has to be taken into consideration whether extending and retraining the machine learning models is worth the effort, especially since this idea is still not proven as a solution. Otherwise, implementing a mathematical schedulability analysis that considers mixed criticality is necessary. A second extension that should be performed in the planning stage is to penalize the migration of higher criticality tasks, as the migration overhead adds an additional risk for the tasks failing. 

The next step in the development of this strategy is the execution of the migration, which is the most important part of the implementation, especially considering the necessity to meet strict timing constraints for tasks at the higher end of the criticality spectrum. While the exact approach is yet to be proven as feasible, an idea for higher criticality tasks would be to let them run in a standby state in all or a subset of the total of available ECUs, and only executing it in one ECUm while storing runtime generated data either in a central unit or in a shared memory only accessible to highly critical tasks, in this way only a start/stop signal is sent to the task and the execution can be resumed quickly, also ensuring fail-safety in case the executing device fails. Another addition in this stage should be the introduction of a real-time capable communication protocol. In this sense, it should be possible to bound the migration time for this tasks. These ideas could be faster to execute and allow for less variance in the time, eventually making it possible to perform formal verification, but it would be expensive if tasks at all criticality levels were to run like that, as the resources are utilized inefficiently. This should be acceptable for highly critical tasks, though, since the majority of the tasks would be assigned low to medium criticality levels.

The strategy for lower criticality tasks would be prone to more flexibility, so that a wider range of tasks can be deployed with a lower impact in terms of resource efficiency, even if this would open the possibility for more erroneous behavior in the tasks. An idea for tasks with the lowest criticality would be the transmission of precompiled task binaries and a snapshot of the execution data every time a task is distributed to an ECU and the usage of a normal TCP/IP protocol over Ethernet. With this strategy, the resource utilization in the devices is made more efficient, but the time spent for the migration is reduced as the communication is slower due to the amount of information exchanged, and also less reliable due to the communication protocol. The exploration of strategies for more criticality levels is yet to be done, but a few ideas are suggested. First, a combination of the two strategies mentioned could be implemented for intermediate criticality levels, such as leaving the tasks running but using a less predictable communication protocol. Another idea is to subdivide each of the criticality levels mentioned and there perform variations of the mentioned strategy. For example, in a system with a certain number of devices and 2 high criticality sublevels, the highest sublevel tasks are kept in standby on all devices, while the rest are only kept in standby in a few of the devices, making sure there is always an ECU ready for the highest criticality and using less resources for the second sublevel. In the case of lower criticality, this could be implemented in the form of giving priority to the migration and transmission of data of tasks at the higher sublevels.

To achieve the results expected as described in the previous paragraphs, the work is organized as follows:

\begin{enumerate}
	\item	Building of the hardware and software system
	
	Finding a real-time platform that allows the further research of the approach described is the first step in the development. Important features to be fulfilled by the system would be the real-time capabilities, integrating a global clock, a multiple-core platform, the integration of mixed-criticality scheduling and a low latency real-time network. For this purpose, an initial idea is to build upon the platform used before at the institute, which consists on UltraScale+ devices running FreeRTOS as operating system, particularly the Ultra96 development boards. However, research will be performed to evaluate other options and the implementation of some features using virtual machines, so that all development does not depend on hardware.
	
	\item	Development of use cases and testing scenarios
	
	An important step in finding the applicability of the developed approach and the evaluation and comparison of the different variations is the development of testing scenarios. This includes the development of tasks at each of the many criticality levels, as well as use cases that put the system under test, such as the failure of a device or the distribution of a higher number of tasks at different criticality levels. Also, inspired by the hardware-in-the-loop setups developed in KIA4SM and by Delgadillo, it would be interesting to add such a scenario to test the approach under a simulation with visual feedback.
	
	\item	Integration and adaptation of the planning strategy
	
	This includes finding the right strategy for the planning stage, either supported by machine learning or not. Additionally, this includes the effort spent in adapting and integrating the selected approach with the mixed criticality concept and developing or adapting a central unit to coordinate the task migration.
	
	\item	Definition and implementation of the approach for highest criticality
	
	The implementation of a strategy for migration of tasks with the highest criticality level is the most important part of the execution. This includes ensuring the migration is time-bounded, and also ensuring that it is integrated properly with the mixed-criticality scheduler. The actual migration strategy and the communication protocol are also implemented in this stage.
	
	\item	Definition and implementation of the approach for lowest criticality
	
	Implementing the strategy for the lower criticality would require less focus on the time-bounded properties and rather more on the resource efficiency over longer periods of time. For this reason, finding a simple strategy that would require the least usage of resources is the focus in this part of the work.

	\item	Definition and implementation of the strategies for intermediate criticality levels
	
	While the exact strategy is still unclear, this is the final step in integrating a multiple level mixed-criticality approach in the migration process. This includes researching and finding the proper strategy for a balance at the intermediate levels between resource efficiency and reliability and fast migration.
	
	\item	Evaluation of the results
	
	This part of the work is the one that will allow to evaluate the contributions made in the research and the variations explored. This evaluation will allow for a comparison with related work to show the validity of the developments and the strategies used. This evaluation shall include timing measurements, as well as other performance metrics related to resource efficiency. Also, the evaluation shall be based on the verification for the higher criticality levels.
\end{enumerate}

\begin{itemize}
\item - Investigate the integration of mixed criticality into the task migration process
\item - Different migration strategies for different criticality levels
\item - Integration of a multiple-level mixed-criticality scheduler in each of the devices. Several options exist, so the challenge is integrating them into the system and with the migration strategy. Possibly compare performance of a few approaches after integration.
\item - The definition of criticality is explored in the form of many levels. Probably using SIL standard from automotive systems, but not restricted to it.
\item - Penalize migration of higher criticality tasks, but also ensure their migration has less risk of failing when meeting deadlines
\item - As the process is real time, it is important to make sure common time for the deadlines is being kept. Probably implement a protocol similar to PTP. This is particularly crucial for ensuring high criticality tasks precisely meet deadlines when migrating.
\item - Strategy for HI criticality would be a lightweight process where only minimal context information for the task would be transmitted. Task would be kept in a standby mode in different devices, waiting to be started with context information when ready. This is non-ideal for all tasks, since resources are under-utilized if all tasks would be kept in the system memory in all devices, but would help allow higher reliability for critical tasks
\item - Ensure fail-safety by keeping a backup of the task context somewhere else than in device internal memory
\item - For HI criticality tasks, ensure migration and restoring of the task is time-bounded, in the ms range. This means also restricting the transmission time, for which a real-time communication protocol should be used
\item - For LO critical tasks, which probably are more than the HI criticality tasks, a complete snapshot of the task with the binary could be stored and transmitted. This would reduce the resource utilization overhead for keeping tasks in memory
\item - As these tasks are less critical, transmission could occur through another transmission channel that is less suitable for real-time, but less expensive, such as Ethernet
\item - Additionally, the idea of mixed criticality explored consists of more than just two levels, for which reason strategies for intermediate levels have to be explored. For example, combinations of the strategies for transmission and execution. 
\item - Ideas for the task migration planning. Since the focus of the research is the execution, this part would be an extension or adaptation from previous work: Implement an exact approach that penalizes migration of higher criticality tasks, maybe taking into account the worst case migration time, here one challenge might be executing the planning in real time. Or extend the ML approach from Blieninger to learn from the criticality levels, here the challenge is to mix in the levels, which could add complexity to the net.
\end{itemize}



As mentioned above, in this master’s thesis, I aim to develop a Hardware-in-the-Loop setup for a model car or robot, using the NeuroRobotics Platform, embedded hardware and a neuromorphic platform, which will be running a machine learning algorithm for migration planning. This would allow for a new task distribution in a given failure scenario for one of the devices in the system. The NRP will provide the virtual environment for the car and the embedded hardware shall mimic a car to show its capabilities in a real situation.

The proposed Hardware-in-the-Loop setup consists of a virtual domain and a real, embedded domain, which interact with each other through the exchange of important information, such as sensor data and control commands. The virtual domain includes the NRP scenario, along with the ROS\footnote{ROS - Robot Operating System, website: https://www.ros.org/} topics / services for the interaction and the Gazebo model for the robot; this stage emulates the sensors and actuators as interfaces with the environment. The embedded domain refers to the model car architecture described below, running on embedded devices with FreeRTOS; these devices are responsible for executing the autonomous driving tasks, such as pathfinding, reading signals from the sensors, generating signals for motor control, and some dummy tasks to keep system utilization high. The utilization is artificially kept high to test the setup under critical situations, which could cause task sets to be unschedulable and deadlines to be missed, which should be mitigated by planning a new task distribution. Additionally, to perform the planning, a SpiNNaker neuromorphic board executes the machine learning algortithm for the schedulability analysis.

The NRP scenario shall present a pathfinding task for the robot in a labyrinth. This will be further extended by allowing for the connection with the real embedded hardware mimicking the car. This connection shall enable the exchange of the relevant sensor and control signals and will be implemented by ROS topics / services. ROS is chosen because it is already used in the NRP and Gazebo, and because it offers a simple way for communicating the virtual environment with the embedded devices, potentially reducing the development time for this stage.

The model car architecture consists of various embedded boards running on FreeRTOS, which will execute the afore mentioned tasks with real-time constraints. The path planning task shall be implemented, along with the reading of sensors and generation of control signals. Dummy tasks, on the other hand will be provided by COBRA framework, along with their execution times. 

To complete the work within the envisaged time frame, certain parts of the machine learning approach shall be taken from previous works, especially the training data and some ideas for the neural network. The training data that has been previously generated in those projects shall be reutilized as much as possible, and for this purpose the dummy tasks shall be generated with the COBRA framework and shall resemble the ones utilized in MaLSAMi. Since the machine learning algorithms have not been implemented on the SpiNNaker board yet, a feed-forward net will be the initial approach, because it can be transformed to run on the neuromorphic board.

Tasks / Work Packages:
\begin{enumerate}
\item	Building of the hardware and software system

Finding a real-time platform that allows the further research of the approach described is the first step in the development. Important features to be fulfilled by the system would be the real-time capabilities, integrating a global clock, a multiple-core platform, the integration of mixed-criticality scheduling and a low latency real-time network. For this purpose, an initial idea is to build upon the platform used before at the institute, which consists on UltraScale+ devices running FreeRTOS as operating system, particularly the Ultra96 development boards.

\item	Integration of the model car in the NeuroRobotics Platform as the real robot. This way, the HIL setup can run the tasks in the embedded devices.

The virtual robot in the NRP shall communicate with the model car by means of ROS topics / services. These shall allow the embedded devices in the model car to execute the path planning tasks based on the emulated sensor signals received and to send control signals to the virtual robot. The tasks to be considered in this stage are establishing the communication of both parts of the setup, the definition of the type of interfaces to be used (topics or services) and their implementation on the NRP simulation and on the embedded hardware.

\item	Porting of the application in 1. to the real model car, so it can be executed on the embedded board, and development of additional dummy applications to ensure system utilization will be high to critical.

The application developed in 1. shall be executed on real devices running on FreeRTOS. For this purpose, the application must be rewritten to C++ code and extended to use the ROS topics or services developed in 2. for reading the sensors and controlling the robot. The dummy tasks shall be generated using COBRA framework and basic FreeRTOS tasks, to resemble the tasks used in MaLSAMi. Using COBRA framework, we can also generate task sets with Worst-Case-Execution-Times, which will be used later as input for the machine learning algorithm.

\item	Creation of an application failure scenario using the hybrid simulation setup (NRP + model car).

A scenario shall be created to make the system fail in fulfilling all real-time constraints for the task set under the original task distribution. The failure scenario must ensure that the system is brought to its limits, so following are possible scenarios: a) suddenly shutting down one of the embedded boards, b) firing additional dummy tasks to force an utilization greater than 1 for one of the boards. After entering either of these scenarios, the system should only be able to meet all constraints by redistributing the tasks to the devices. Relevant tasks in this stage are the decision and implementation of the strategy for causing the failure, as well as ensuring that the system is brought to a critical state.

\item	Mitigation of the application failure / recovery of the system using task re-deployment based on migration planning and machine learning performed on the SpiNNaker neuromorphic board

Based on previous work, a machine learning approach for schedulability analysis shall be implemented on the SpiNNaker board. Therefore, the first task is to create a feed-forward net that can be transformed to the neuromorphic board for this use case. Then the connection between the boards and the migration planning algorithm should be established. Afterwards, the planned distribution shall be achieved by redeploying the tasks onto the devices that are still available. Here, it shall be ensured that a feasible task distribution is selected.

\item	Timing evaluation of the results

With hardware or software tools, the time between system failure and deployment of a feasible task configuration shall be measured. For this, time consumed in intermediate steps (such as the task distribution planning and the deployment) might be measured using End-to-End measurement. The results of these measurements shall be compared then to ones from previous works, such as those by Utz~\parencite{utz1} and Blieninger~\parencite{blieninger1}.
\end{enumerate}

This stage and task definition permits the fulfillment of the goal of the master’s thesis in the planned time, as detailed in the time plan below. 

\section*{Time Plan}\label{section:timeplan}
The work will be organized in the work packages described below, whose relation to the stages described before is indicated in parenthesis. Some work packages are divided in subpackages for a more detailed description of the work comprised in them.

\begin{center}
\begin{ganttchart}[
	hgrid,
	expand chart=\textwidth
	]{1}{48}
	\gantttitle{Time Plan (weeks)}{48} \\
	%\gantttitlelist{1,...,24}{2} \\
	\ganttbar[bar/.append style={fill=TUMBlue}]{WP1}{1}{6} \\
	\ganttbar[bar/.append style={fill=TUMAccentOrange}]{WP2}{7}{13} \\
	\ganttbar[bar/.append style={fill=TUMGray}]{WP3}{14}{18} \\
	\ganttbar[bar/.append style={fill=TUMSecondaryBlue2}]{WP4}{19}{22} \\
	\ganttbar[bar/.append style={fill=TUMAccentGreen}]{WP5}{23}{34} \\
	\ganttbar[bar/.append style={fill=TUMAccentGray}]{WP6}{35}{40} \\
	\ganttbar[bar/.append style={fill=TUMAccentLightBlue}]{WP7}{41}{48}
	\ganttvrule{0}{0}
	\ganttvrule{4}{8}
	\ganttvrule{8}{16}
	\ganttvrule{12}{24}
	\ganttvrule{16}{32}
	\ganttvrule{20}{40}
	\ganttvrule{24}{48}
\end{ganttchart}
\end{center}


\begin{enumerate}
\item [WP1.] Initial setup of the existing independent components in the full system and familiarization with previous work and the algorithms and architectures used (3 weeks)
	\begin{enumerate}
	\item [a.]	Familiarization with previous work and other literature (1.5 weeks)
	\item [b.]	Setup of the software tools to be used and familiarization with them (1.5 weeks)
	\end{enumerate}
\item [WP2.] Setup of initial NRP scenario (1.) and embedded hardware, along with their integration (2.) (3.5 weeks)
	\begin{enumerate}
	\item [a.]	Creation of initial NRP scenario and simple application (1 week)
	\item [b.]	Creation of ROS topics and services that will serve as interface with model car (0.5 weeks)
	\item [c.]	Setup of embedded hardware (1 week)
	\item [d.]	Integration of model car hardware with NRP scenario using the topics and services created (1 week)
	\end{enumerate}
\item [WP3.] Development of the applications to be run on the hardware (3.) (2.5 weeks)
	\begin{enumerate}
	\item [a.]	Development of path planning application (1.5 weeks)
	\item [b.]	Development of dummy applications to ensure critical system utilization (1 week)
	\end{enumerate}
\item [WP4.] Creation of application failure scenario (4.) (2 weeks)
\item [WP5.] Setup and integration of SpiNNaker board for performing the schedulability analysis and planning the task distribution (5.) (6 weeks)
	\begin{enumerate}
	\item [a.]	Setup and integration of SpiNNaker board (1.5 weeks)
	\item [b.]	Implementation of the machine learning algorithm (2.5 weeks)
	\item [c.]	Integration and implementation of the task distribution strategy (2 weeks)
	\end{enumerate}
\item [WP6.] Collection and analysis of the results (5.) (3 weeks)
	\begin{enumerate}
	\item [a.]	Refinement of HIL setup to show that the system can recover from the failure scenario implemented using the task distribution strategy (1.5 weeks)
	\item [b.]	Timing analysis of the results (6.) (1.5 weeks)
	\end{enumerate}
\item [WP7.] Conclusion of the work and writing of the thesis (4 weeks)
\end{enumerate}

\section*{Necessary Software and Hardware Components}\label{section:necessarycomponents}
In order to fulfill the purpose of the master’s thesis in the planned time, I expect to need following materials:

\begin{itemize}
	\item	Setup with several embedded systems with FreeRTOS
	\item	Work station for machine learning before test execution
	\item	Work station for running NeuroRobotics Platform
	\item	SpiNNaker board for executing machine learning at runtime
\end{itemize}